<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<meta name="generator" content="litedown 0.7.1">
<title>Debug in aes() contexts</title>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@xiee/utils@1.14.14/css/default.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@xiee/utils@1.14.14/css/article.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@xiee/utils@1.14.14/css/copy-button.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@xiee/utils@1.14.14/css/heading-anchor.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@xiee/utils@1.14.14/css/pages.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@xiee/utils@1.14.14/css/site.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@xiee/utils@1.14.14/css/prism-xcode.min.css">
<script src="https://cdn.jsdelivr.net/npm/@xiee/utils@1.14.14/js/sidenotes.min.js" defer></script>
<script src="https://cdn.jsdelivr.net/npm/@xiee/utils@1.14.14/js/appendix.min.js" defer></script>
<script src="https://cdn.jsdelivr.net/npm/@xiee/utils@1.14.14/js/toc-highlight.min.js" defer></script>
<script src="https://cdn.jsdelivr.net/npm/@xiee/utils@1.14.14/js/copy-button.min.js" defer></script>
<script src="https://cdn.jsdelivr.net/npm/@xiee/utils@1.14.14/js/heading-anchor.min.js" defer></script>
<script src="https://cdn.jsdelivr.net/npm/@xiee/utils@1.14.14/js/pages.min.js" defer></script>
<script src="https://cdn.jsdelivr.net/npm/@xiee/utils@1.14.14/js/external-link.min.js" defer></script>
<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js" defer></script>
<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js" defer></script>
</head>
<body>
<nav><p><strong>June Choe’s Micro Blog</strong> <a href="../index.html">Posts</a> <a href="../about.html">About</a></p></nav>
<div class="frontmatter">
<div class="title"><h1>Debug in <code>aes()</code> contexts</h1></div>
<div class="date"><h3>2025-08-07</h3></div>
</div>
<div class="body">
<div id="TOC">
<ul>
<li><a href="#sec:motivation">Motivation</a></li>
<li><a href="#sec:hacks">Hacks</a></li>
<li><a href="#sec:inspect-the-stack">Inspect the stack</a></li>
<li><a href="#sec:just-use-ggtrace">Just use ggtrace</a></li>
<li><a href="#chp:sessioninfo"><code>sessionInfo()</code></a></li>
</ul>
</div>
<!-- pre-hook -->
<p>You can inspect <code>after_stat()</code> and <code>after_scale()</code> contexts, but there’s a twist.</p>
<h2 id="sec:motivation">Motivation</h2>
<p>The functions <code>after_stat()</code> and <code>after_scale()</code> (and the more primitive form <code>stage()</code>) in ggplot let you access variables that are calculated internally in the layer-building pipeline. For example:</p>
<pre><code class="language-r">library(ggplot2)
library(colorspace)
ggplot(mtcars, aes(cyl, fill = as.factor(cyl))) +
  geom_bar(
    aes(
      y = after_stat(count),
      color = after_scale(darken(fill))
    ),
    linewidth = 3
  )
</code></pre>
<p><img src="posts/debug-in-aes-contexts__files/chunk-2-1.png" alt="" /></p>
<p>We typically get limited visibility into the process. Unless…</p>
<h2 id="sec:hacks">Hacks</h2>
<p>Let’s use a trivial example to mess around with:</p>
<pre><code class="language-r">p &lt;- ggplot(data.frame(x = 1, y = 1), aes(x, y)) +
  geom_label()
p +
  aes(
    label = after_stat(&quot;text&quot;),
    color = after_scale(&quot;red&quot;)
  )
</code></pre>
<p><img src="posts/debug-in-aes-contexts__files/chunk-3-1.png" alt="" /></p>
<p>We can grab variables in the data-mask with <code>ls(.top_env)</code> and print them:</p>
<pre><code class="language-r">invisible(ggplot_build(
  p +
    aes(
      label = after_stat({
        cat(&quot;after stat variables:\n&quot;)
        print(ls(.top_env))
        &quot;text&quot;
      }),
      color = after_scale({
        cat(&quot;\nafter scale variables:\n&quot;)
        print(ls(.top_env))
        &quot;red&quot;
      })
    )
))
</code></pre>
<pre><code>#&gt; after stat variables:
#&gt; [1] &quot;group&quot; &quot;PANEL&quot; &quot;x&quot;     &quot;y&quot;    
#&gt; 
#&gt; after scale variables:
#&gt;  [1] &quot;alpha&quot;      &quot;angle&quot;      &quot;colour&quot;     &quot;family&quot;     &quot;fill&quot;      
#&gt;  [6] &quot;fontface&quot;   &quot;group&quot;      &quot;hjust&quot;      &quot;label&quot;      &quot;lineheight&quot;
#&gt; [11] &quot;linetype&quot;   &quot;linewidth&quot;  &quot;nudge_x&quot;    &quot;nudge_y&quot;    &quot;PANEL&quot;     
#&gt; [16] &quot;size&quot;       &quot;vjust&quot;      &quot;x&quot;          &quot;y&quot;         
</code></pre>
<div class="side side-right">
<p>Note that this doesn’t fully reconstruct the layer data; namely, the column order is lost.</p>
</div>
<p>We can also print their values. Here, I’m throwing them into a dataframe to compactly display all of them</p>
<pre><code class="language-r">invisible(ggplot_build(
  p +
    aes(
      label = after_stat({
        cat(&quot;after stat variables:\n&quot;)
        print(as.data.frame(mget(ls(.top_env), .top_env)))
        &quot;text&quot;
      }),
      color = after_scale({
        cat(&quot;\nafter scale variables:\n&quot;)
        print(as.data.frame(mget(ls(.top_env), .top_env)))
        &quot;red&quot;
      })
    )
))
</code></pre>
<pre><code>#&gt; after stat variables:
#&gt;   group PANEL x y
#&gt; 1    -1     1 1 1
#&gt; 
#&gt; after scale variables:
#&gt;   alpha angle colour family  fill fontface group hjust label lineheight
#&gt; 1    NA     0  black        white        1    -1   0.5  text        1.2
#&gt;   linetype linewidth nudge_x nudge_y PANEL     size vjust x y
#&gt; 1        1      0.25       0       0     1 3.866058   0.5 1 1
</code></pre>
<p>What’s funny about this is that if you add a legend to the plot, <code>after_stat()</code> is evaluated twice.</p>
<pre><code class="language-r">invisible(ggplot_build(
  p +
    aes(
      label = after_stat({
        cat(&quot;after stat variables:\n&quot;)
        print(as.data.frame(mget(ls(.top_env), .top_env)))
        &quot;text&quot;
      }),
      color = after_scale({
        cat(&quot;\nafter scale variables:\n&quot;)
        print(as.data.frame(mget(ls(.top_env), .top_env)))
        &quot;red&quot;
      })
    ) +
    scale_discrete_identity(&quot;label&quot;, guide = &quot;legend&quot;)
))
</code></pre>
<pre><code>#&gt; after stat variables:
#&gt;   group PANEL x y
#&gt; 1    -1     1 1 1
#&gt; 
#&gt; after scale variables:
#&gt;   alpha angle colour family  fill fontface hjust label lineheight linetype
#&gt; 1    NA     0  black        white        1   0.5  text        1.2        1
#&gt;   linewidth     size vjust
#&gt; 1      0.25 3.866058   0.5
#&gt; 
#&gt; after scale variables:
#&gt;   alpha angle colour family  fill fontface group hjust label lineheight
#&gt; 1    NA     0  black        white        1    -1   0.5  text        1.2
#&gt;   linetype linewidth nudge_x nudge_y PANEL     size vjust x y
#&gt; 1        1      0.25       0       0     1 3.866058   0.5 1 1
</code></pre>
<div class="side side-right">
<p>This is a relatively new in internal change in ggplot.</p>
</div>
<p>That’s because after scale mappings are resolved once for the guides, and then a second time for the layer geom.</p>
<h2 id="sec:inspect-the-stack">Inspect the stack</h2>
<p>The only way to disambiguate the two <code>after_scale()</code> evaluations is to see where they were called from. Unfortunately, <code>sys.calls()</code> doesn’t seem to work.</p>
<pre><code class="language-r">invisible(ggplot_build(
  p +
    aes(
      label = after_stat({
        print(sys.calls())
        &quot;text&quot;
      }),
      color = after_scale({
        print(sys.calls())
        &quot;red&quot;
      })
    ) +
    scale_discrete_identity(&quot;label&quot;, guide = &quot;legend&quot;)
))
</code></pre>
<pre><code>#&gt; NULL
#&gt; NULL
#&gt; NULL
</code></pre>
<p>For some reason, you need to wrap <code>sys.calls()</code> in a function to recover the stack. So I write a IIFE here:</p>
<pre><code class="language-r">invisible(ggplot_build(
  p +
    aes(
      label = after_stat({
        print((\()sys.calls())() |&gt; length())
        &quot;text&quot;
      }),
      color = after_scale({
        print((\()sys.calls())() |&gt; length())
        &quot;red&quot;
      })
    ) +
    scale_discrete_identity(&quot;label&quot;, guide = &quot;legend&quot;)
))
</code></pre>
<pre><code>#&gt; [1] 44
#&gt; [1] 58
#&gt; [1] 52
</code></pre>
<p>Ok good. So back on after scale, if we only want to evaluate something in the after scale context for the layer (not the legend), we wanna latch onto some identifiable call upstream. I’m gonna use called-from-<code>by_layer()</code> as the proxy here.</p>
<pre><code class="language-r">called_from_by_layer &lt;- function(x) {
  any(as.character(sapply(x, `[[`, 1)) == &quot;by_layer&quot;)
}
</code></pre>
<p>So then we can use that to return different values for the layer geom vs. the legend.</p>
<pre><code class="language-r">p +
  aes(
    label = after_stat(&quot;text&quot;),
    color = after_scale({
      if (called_from_by_layer((\()sys.calls())())) {
        &quot;red&quot;
      } else {
        &quot;blue&quot;
      }
    })
  ) +
  scale_discrete_identity(&quot;label&quot;, guide = &quot;legend&quot;)
</code></pre>
<p><img src="posts/debug-in-aes-contexts__files/chunk-10-1.png" alt="" /></p>
<h2 id="sec:just-use-ggtrace">Just use ggtrace</h2>
<p>Don’t actually do all of this though. If you’re curious about the internals, just use ggtrace! :)</p>
<a href="https://github.com/yjunechoe/ggtrace">
  <img src="https://github.com/yjunechoe/ggtrace/raw/main/man/figures/logo.png" 
       width="300" 
       height="300">
</a>
<hr />
<!-- post-hook -->
<h1 id="chp:sessioninfo"><code>sessionInfo()</code></h1>
<details>
<summary>Session info</summary>
<pre><code class="language-r">sessionInfo()
</code></pre>
<pre><code>#&gt; R version 4.4.1 (2024-06-14 ucrt)
#&gt; Platform: x86_64-w64-mingw32/x64
#&gt; Running under: Windows 11 x64 (build 26100)
#&gt; 
#&gt; Matrix products: default
#&gt; 
#&gt; 
#&gt; locale:
#&gt; [1] LC_COLLATE=English_United States.utf8 
#&gt; [2] LC_CTYPE=English_United States.utf8   
#&gt; [3] LC_MONETARY=English_United States.utf8
#&gt; [4] LC_NUMERIC=C                          
#&gt; [5] LC_TIME=English_United States.utf8    
#&gt; 
#&gt; time zone: America/New_York
#&gt; tzcode source: internal
#&gt; 
#&gt; attached base packages:
#&gt; [1] stats     graphics  grDevices utils     datasets  methods   base     
#&gt; 
#&gt; other attached packages:
#&gt; [1] colorspace_2.1-1   ggplot2_3.5.2.9001
#&gt; 
#&gt; loaded via a namespace (and not attached):
#&gt;  [1] vctrs_0.6.5            cli_3.6.3              rlang_1.1.4           
#&gt;  [4] xfun_0.52              generics_0.1.3         S7_0.2.0              
#&gt;  [7] litedown_0.7.1         glue_1.7.0             labeling_0.4.3        
#&gt; [10] scales_1.4.0           grid_4.4.1             tibble_3.2.1          
#&gt; [13] lifecycle_1.0.4        compiler_4.4.1         dplyr_1.1.4           
#&gt; [16] codetools_0.2-20       RColorBrewer_1.1-3     pkgconfig_2.0.3       
#&gt; [19] rstudioapi_0.17.1.9000 farver_2.1.2           R6_2.6.1              
#&gt; [22] tidyselect_1.2.1       pillar_1.10.1          commonmark_1.9.5      
#&gt; [25] magrittr_2.0.3         tools_4.4.1            withr_3.0.2           
#&gt; [28] gtable_0.3.6          
</code></pre>
</details>
</div>
<footer><p>© 2025 <a href="https://yjunechoe.github.io/">June Choe</a>.
Site built with <a href="https://github.com/yihui/litedown">litedown</a>.
<img src="https://i.creativecommons.org/l/by/4.0/80x15.png" alt="CC BY" /> <a href="http://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a>.</p></footer>
</body>
</html>
